/*********************************************************************** * Program: *    Week 13, GENEALOGY *    Brother Ercanbrack, CS 235 * Author: *    Daniel Thomson * Summary: *		The purpose of this assignment is to combine the knowledge you *		have accumulated this semester to solve a problem ************************************************************************/  // VS doesn't like strcmp #ifdef _MSC_VER #define _CRT_SECURE_NO_WARNINGS #endif  #include "individual.h" // A person #include <iostream>	// for CIN and COUT #include <fstream>	// Writing to files  #include <istream>	// Reading files in #include <string>		// String class #include <cstring>   // for strcmp #include "bnode.h"	// Homemade Binary Node class for BNode linked list #include "list.h"		// Homemade list class #include "merge.h"	// for Sorting the list  typedef BinaryNode <Individual> record; // used in pedigree()  using namespace std;  //Prototypes void genealogy(char * fileName); List <Individual> getSortedData(char * fileName); void writeToFile(const List <Individual> & data); List <record *> makePedigree(List <Individual> data, char * fileName); void displayTree(const List <record *> & tree);  /**********************************************************************  * MAIN  * Gets the  filename from the command line. If the filename is not  * entered on the command line, the user will be prompted for the  * filename.  ***********************************************************************/ int main(int argc, const char* argv[]) { 	char fileName[50]; 	if (argc == 1) 	{ 		cout << "Enter a GED file to read: "; 		cin >> fileName; 	} 	else if (argc == 2) 	{ 		strcpy(fileName, argv[1]); 	}  	genealogy(fileName);  	return 0; }  /********************************************************************  * Genealogy  * Using an old LDS church GEDCOM genealogical  * file display the individual ancestors  ********************************************************************/ void genealogy(char * fileName) { 	// Get data 	List <Individual> records = getSortedData(fileName);  	// Write to screen and file 	writeToFile(records);  	// Build a pedigree from A Binary tree 	List <record *> tree = makePedigree(records, fileName);  	//Display the tree 	displayTree(tree); }  /***************************************************************  * GET DATA  * Read and decipher the .GED file to get the disired data.  * Then sort them into a list  **************************************************************/ List <Individual> getSortedData(char * fileName) { 	// Container to keep the data 	List <Individual> data;  	string line; // Get one line at a time 	int length; // Determining the length of strings  	// Open file 	ifstream fin(fileName);  	// Check for opening errors 	if (fin.fail()) 	{ 		cout << "Failed to read file."; 		return data; 	}  	// Read the data 	while (getline(fin, line)) 	{ 		// Data we're looking for 		string id; 		string firstName; 		string lastName; 		string dateOfBirth;  		// Check to see if it's a desirable entry 		if (line.substr(2, 2) == "@I") 		{ 			length = line.find_last_of("@"); 			id = line.substr(4, (length - 4)); // get the ID 			while (getline(fin, line) && line.substr(0, 6) != "3 TIME") // Distance between records 			{ 				if (line.substr(2, 4) == "GIVN") // Get the FIRST NAME 				{ 					length = line.length() - 7; 					firstName = line.substr(7, length); 				} 				if (line.substr(2, 4) == "SURN") // Get the LAST NAME 				{ 					length = line.length() - 7; 					lastName = line.substr(7, length); 				} 				if (line.substr(2, 4) == "BIRT") // Get the DATE OF BIRTH  				{ 					getline(fin, line); // Skip the heading  					if (line.substr(2, 4) == "DATE") 					{ 						length = line.length() - 7; 						dateOfBirth = line.substr(7, length); 					} 				} 			} 			Individual record(id, firstName, lastName, dateOfBirth); 			data.push_back(record); 		} 	} 	// Close the file 	fin.close();  	// sort the list 	mergeSort(data);  	return data; }  /***************************************************************  * Write To FILE  * Write the data to the screen and to a .DAT file  **************************************************************/ void writeToFile(const List <Individual> & data) { 	ofstream fout("sorted.dat");  	if (fout.fail()) 	{ 		cout << "Failed to write file."; 		return; 	} 	ListIterator <Individual> it; 	for (it = data.begin(); it != data.end(); it++) 	{ 		cout << *it; // to screen 		fout << *it; // to file 	}  	// Close the file 	fout.close(); }  /********************************************************************  * Make Pedigree  * Take the sorted binary linked list and make a pedigree from it  *******************************************************************/ List <record *> makePedigree(List <Individual> data, char * fileName) { 	List <record *> pedigree; // list to be written to 	ListIterator <Individual> it; 	for (it = data.begin(); it != data.end(); it++) 	{ 		record * temp; 		try 		{ 			temp = new record(*it); // convert data to binary node 		} 		catch (bad_alloc) 		{ 			cout << "No memory for record allocation"; 		} 		pedigree.push_back(temp); // copy the data over.	 	} 	// Open file 	ifstream fin(fileName);  	// Check for opening errors 	if (fin.fail()) 	{ 		cout << "Failed to read file."; 		return pedigree; 	} 	string line; // Get one line at a time 	int length; // Determining the length of strings  	while (!fin.eof()) 	{ 		// Data we're looking for 		string dad; 		string mom; 		string child;  		getline(fin, line); 		 		if (!line.empty()) 		{ 			// Check to see if it's a desirable entry 			if (line.substr(2, 2) == "@F") 			{ 				getline(fin, line); 				if (line.substr(2, 2) == "@F") 				{ 					getline(fin, line); 				} 				if (line == "1 DIV Y") 				{ 					getline(fin, line); 				} 				if (line.substr(2, 4) == "HUSB") 				{ 					length = line.find_last_of("@"); 					dad = line.substr(9, (length - 9)); 					getline(fin, line); 				} 				if (line.substr(2, 4) == "WIFE") 				{ 					length = line.find_last_of("@"); 					mom = line.substr(9, (length - 9)); 					getline(fin, line); 				} 				if (line.substr(2, 4) == "CHIL") 				{ 					length = line.find_last_of("@"); 					child = line.substr(9, (length - 9)); 				}  				// Used in linear search for data 				ListIterator <record *> childIt; 				record * childNode; 				ListIterator <record *> dadIt; 				record * dadNode; 				ListIterator <record *> momIt; 				record * momNode;  				if (!child.empty() || !dad.empty() || !mom.empty()) 				{ 					// Build the Pedigree Tree 					for (childIt = pedigree.begin(); childIt != pedigree.end(); childIt++) 					{ 						// find the child 						if ((*childIt)->data.getID() == child) 						{ 							childNode = *childIt; 							// Then find the parents 							for (dadIt = pedigree.begin(); dadIt != pedigree.end(); dadIt++) 							{ 								if ((*dadIt)->data.getID() == dad) 								{ 									dadNode = *dadIt; 									childNode->addLeft(dadNode); // Set the pointer 								} 							} 							for (momIt = pedigree.begin(); momIt != pedigree.end(); momIt++) 							{ 								if ((*momIt)->data.getID() == mom) 								{ 									momNode = *momIt; 									childNode->addRight(momNode); // Set the pointer 								} 							} 						} 					} 				} 			} 		} 	} 	// Close the file 	fin.close();  	return pedigree; }  /********************************************************************  * Make Pedigree  * Print out the pedigree tree in level (ancestral) order  *******************************************************************/ void displayTree(const List <record *> & tree) { 	record * root; 	ListIterator <record *> it; 	cout << endl;  	cout << "The Ancestors of ";  	for (it = tree.begin(); it != tree.end(); it++) 	{ 		if ((*it)->data.getID() == "1") 		{ 			root = *it; 			root->data.setLastName(root->data.getLastName() + ":"); 			root->data.setDateOfBirth(""); 			root->level(); 		} 	} }